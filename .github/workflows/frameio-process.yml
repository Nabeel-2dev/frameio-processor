name: Frame.io Folder Processor

on:
  repository_dispatch:
    types: [process-folder]

env:
  AIRTABLE_TOKEN: ${{ secrets.AIRTABLE_TOKEN }}
  AIRTABLE_BASE_ID: ${{ secrets.AIRTABLE_BASE_ID }}
  TABLE_NAME: "Result%20Folders"

jobs:
  process-folder:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    
    steps:
    - name: Extract Parameters
      id: params
      run: |
        echo "folder_url=${{ github.event.client_payload.folderUrl }}" >> $GITHUB_OUTPUT
        echo "record_id=${{ github.event.client_payload.recordId }}" >> $GITHUB_OUTPUT
        echo "script_url=${{ github.event.client_payload.scriptUrl }}" >> $GITHUB_OUTPUT
        
        echo "ğŸ“ Parameters:"
        echo "  Folder: ${{ github.event.client_payload.folderUrl }}"
        echo "  Record: ${{ github.event.client_payload.recordId }}"
        echo "  Script: ${{ github.event.client_payload.scriptUrl }}"

    - name: Create Helper Scripts
      run: |
        # Create call_script function as a separate file
        cat > /tmp/call_script.sh << 'SCRIPT_EOF'
        #!/bin/bash
        call_script() {
          local action=$1
          local params=$2
          local max_attempts=5
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "ğŸ“ Calling: $action (attempt $attempt/$max_attempts)"
            
            local response=$(curl -s -L \
              --max-time 300 \
              --retry 3 \
              --retry-delay 2 \
              "$SCRIPT_URL?action=$action$params" 2>/dev/null)
            
            if [ $? -eq 0 ] && [ -n "$response" ]; then
              if echo "$response" | grep -q '"ok":true'; then
                echo "$response"
                return 0
              elif echo "$response" | grep -q '"ok":false'; then
                local error=$(echo "$response" | grep -o '"error":"[^"]*"' | sed 's/"error":"//;s/"//')
                
                if [[ "$error" == *"quota"* ]] || [[ "$error" == *"bandwidth"* ]] || [[ "$error" == *"timeout"* ]]; then
                  echo "âš ï¸  Retryable error: $error (attempt $attempt)"
                  sleep $((attempt * 3))
                  attempt=$((attempt + 1))
                  continue
                else
                  echo "âŒ Non-retryable error: $error"
                  echo "$response"
                  return 1
                fi
              fi
            fi
            
            echo "ğŸ”„ Request failed, retrying in $((attempt * 2))s..."
            sleep $((attempt * 2))
            attempt=$((attempt + 1))
          done
          
          echo "âŒ Failed after $max_attempts attempts"
          return 1
        }
        SCRIPT_EOF
        
        chmod +x /tmp/call_script.sh
        
        # Set environment variables
        echo "SCRIPT_URL=${{ steps.params.outputs.script_url }}" >> $GITHUB_ENV
        echo "RECORD_ID=${{ steps.params.outputs.record_id }}" >> $GITHUB_ENV
        echo "FOLDER_URL=${{ steps.params.outputs.folder_url }}" >> $GITHUB_ENV

    - name: Initialize Folder Processing
      id: init
      run: |
        echo "ğŸš€ Starting Frame.io processing..."
        echo "Folder URL: $FOLDER_URL"
        echo "Record ID: $RECORD_ID"
        echo "Script URL: $SCRIPT_URL"
        
        source /tmp/call_script.sh
        
        echo "ğŸ“ Step 1: Initializing folder..."
        init_response=$(call_script "initFolder" "&folderUrl=$FOLDER_URL")
        
        if [ $? -ne 0 ]; then
          echo "âŒ Init error: $(echo "$init_response" | grep -o '"error":"[^"]*"' | sed 's/"error":"//;s/"//')"
          exit 1
        fi
        
        echo "âœ… Initialization successful!"
        echo "$init_response"
        
        # Extract group ID
        group_id=$(echo "$init_response" | grep -o '"groupId":"[^"]*"' | sed 's/"groupId":"//;s/"//')
        
        if [ -z "$group_id" ] || [ "$group_id" = "null" ]; then
          echo "â„¹ï¸  No files found for processing"
          echo "files_found=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "files_found=true" >> $GITHUB_OUTPUT
        echo "GROUP_ID=$group_id" >> $GITHUB_ENV
        echo "ğŸ†” Group ID: $group_id"
        
        # Save response for later use
        echo "$init_response" > /tmp/init_response.json

    - name: Ultra-Fast Parallel Upload
      id: parallel_upload
      if: steps.init.outputs.files_found == 'true'
      run: |
        echo "ğŸš€ Starting ultra-fast parallel asset processing..."
        
        source /tmp/call_script.sh
        
        # Extract asset IDs from the init response
        init_response=$(cat /tmp/init_response.json)
        asset_ids=$(echo "$init_response" | grep -o '"assetId":"[^"]*"' | sed 's/"assetId":"//;s/"//')
        
        if [ -z "$asset_ids" ]; then
          echo "âŒ No asset IDs found"
          exit 1
        fi
        
        echo "ğŸ“Š Assets to process:"
        echo "$asset_ids" | while read -r asset_id; do
          echo "  ğŸ¬ Asset ID: $asset_id"
        done
        
        # Create upload function as separate file
        cat > /tmp/upload_asset.sh << 'UPLOAD_EOF'
        #!/bin/bash
        source /tmp/call_script.sh
        
        upload_asset() {
          local asset_id=$1
          echo "ğŸš€ [$asset_id] Starting ultra-fast upload"
          
          local attempts=0
          local max_attempts=100
          
          while [ $attempts -lt $max_attempts ]; do
            attempts=$((attempts + 1))
            
            # Ultra-aggressive settings
            local response=$(call_script "uploadAsset" "&assetId=$asset_id&budget_ms=300000&window=16&pace_ms=25")
            
            if [ $? -ne 0 ]; then
              echo "âš ï¸  [$asset_id] Call failed, retrying..."
              sleep 2
              continue
            fi
            
            # Check for completion
            if echo "$response" | grep -q '"paused":false'; then
              echo "âœ… [$asset_id] Upload completed!"
              return 0
            fi
            
            # Check for errors
            if echo "$response" | grep -q '"ok":false'; then
              local error=$(echo "$response" | grep -o '"error":"[^"]*"' | sed 's/"error":"//;s/"//')
              echo "âŒ [$asset_id] Error: $error"
              
              if [[ "$error" == *"bandwidth"* ]]; then
                echo "â³ [$asset_id] Bandwidth throttled, backing off..."
                sleep 10
                continue
              elif [[ "$error" == *"quota"* ]]; then
                echo "â³ [$asset_id] Quota hit, waiting..."
                sleep 5
                continue
              else
                return 1
              fi
            fi
            
            # Extract progress
            local uploaded=$(echo "$response" | grep -o '"uploaded":[0-9]*' | sed 's/"uploaded"://')
            local total=$(echo "$response" | grep -o '"totalChunks":[0-9]*' | sed 's/"totalChunks"://')
            
            if [ -n "$uploaded" ] && [ -n "$total" ] && [ "$total" -gt 0 ]; then
              local percentage=$((uploaded * 100 / total))
              echo "âš¡ [$asset_id] Progress: $uploaded/$total chunks ($percentage%)"
            fi
            
            sleep 1
          done
          
          echo "âŒ [$asset_id] Failed after $max_attempts attempts"
          return 1
        }
        
        upload_asset "$1"
        UPLOAD_EOF
        
        chmod +x /tmp/upload_asset.sh
        
        # Launch parallel uploads
        echo ""
        echo "ğŸš€ LAUNCHING PARALLEL UPLOADS..."
        pids=()
        
        while read -r asset_id; do
          if [ -n "$asset_id" ]; then
            echo "ğŸ”¥ Launching upload for asset: $asset_id"
            /tmp/upload_asset.sh "$asset_id" &
            pids+=($!)
            sleep 0.2  # Brief stagger
          fi
        done <<< "$asset_ids"
        
        echo "ğŸ“Š Launched ${#pids[@]} parallel processes"
        
        # Wait for all uploads
        completed=0
        failed=0
        start_time=$(date +%s)
        
        for pid in "${pids[@]}"; do
          if wait $pid; then
            completed=$((completed + 1))
            elapsed=$(($(date +%s) - start_time))
            echo "âœ… Upload completed! ($completed processed, ${elapsed}s elapsed)"
          else
            failed=$((failed + 1))
            elapsed=$(($(date +%s) - start_time))
            echo "âŒ Upload failed! ($failed failed, ${elapsed}s elapsed)"
          fi
        done
        
        total_time=$(($(date +%s) - start_time))
        
        echo ""
        echo "ğŸ† UPLOAD RESULTS:"
        echo "  âœ… Completed: $completed"
        echo "  âŒ Failed: $failed"
        echo "  â±ï¸  Total time: ${total_time}s"
        
        if [ $failed -gt 0 ]; then
          echo "âŒ Some uploads failed"
          exit 1
        fi
        
        echo "ğŸ‰ ALL UPLOADS COMPLETED!"
        echo "files_processed=$completed" >> $GITHUB_OUTPUT

    - name: Finalize and Create Review Link
      id: finalize
      if: steps.init.outputs.files_found == 'true'
      run: |
        echo "ğŸ”— Step 3: Creating Frame.io review link..."
        
        source /tmp/call_script.sh
        
        finalize_response=$(call_script "finalizeFolder" "&groupId=$GROUP_ID")
        
        if [ $? -ne 0 ]; then
          echo "âŒ Finalize error: $(echo "$finalize_response" | grep -o '"error":"[^"]*"' | sed 's/"error":"//;s/"//')"
          exit 1
        fi
        
        echo "âœ… Finalization successful!"
        echo "$finalize_response"
        
        # Extract review link
        review_link=$(echo "$finalize_response" | grep -o '"reviewLink":"[^"]*"' | sed 's/"reviewLink":"//;s/"//')
        
        if [ -z "$review_link" ]; then
          echo "âŒ No review link found in response"
          exit 1
        fi
        
        echo "ğŸ¬ Frame.io Review Link: $review_link"
        echo "review_link=$review_link" >> $GITHUB_OUTPUT

    - name: Update Airtable Record
      if: steps.init.outputs.files_found == 'true'
      run: |
        echo "ğŸ“ Updating Airtable record..."
        
        review_link="${{ steps.finalize.outputs.review_link }}"
        
        echo "âœ… Updating with Frame.io link: $review_link"
        
        curl -X PATCH \
          "https://api.airtable.com/v0/$AIRTABLE_BASE_ID/$TABLE_NAME" \
          -H "Authorization: Bearer $AIRTABLE_TOKEN" \
          -H "Content-Type: application/json" \
          -d "{
            \"records\": [
              {
                \"id\": \"$RECORD_ID\",
                \"fields\": {
                  \"Low Quality Bit.ly Folder Link\": \"$review_link\"
                }
              }
            ]
          }"
        
        echo ""
        echo "âœ… Airtable record updated successfully!"

    - name: Success Summary
      if: steps.init.outputs.files_found == 'true'
      run: |
        echo ""
        echo "ğŸ‰ ========== PROCESSING COMPLETE! =========="
        echo "ğŸ“ Folder: $FOLDER_URL"
        echo "ğŸ†” Record: $RECORD_ID"
        echo "ğŸ“Š Files processed: ${{ steps.parallel_upload.outputs.files_processed }}"
        echo "ğŸ¬ Frame.io link: ${{ steps.finalize.outputs.review_link }}"
        echo "ğŸš€ Status: SUCCESS"
        echo "============================================"

    - name: No Files Found
      if: steps.init.outputs.files_found == 'false'
      run: |
        echo "â„¹ï¸  No 'highlights' or 'teaser' files found in the folder"
        echo "âœ… Job completed successfully (no processing needed)"
